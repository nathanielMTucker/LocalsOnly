{"ast":null,"code":"module.exports = explodeAddress;\nmodule.exports.explodeAddress = explodeAddress;\nmodule.exports.implodeAddress = implodeAddress;\n\nfunction explodeAddress(singleLineAddress, cb) {\n  process.nextTick(function () {\n    var addressObj = {\n      street_address1: null,\n      city: null,\n      state: null,\n      postal_code: null,\n      country: null\n    };\n\n    if (typeof singleLineAddress != 'string') {\n      //return cb(new Error('Input must be a String'))\n      return cb(false, addressObj);\n    }\n\n    singleLineAddress = singleLineAddress.trim();\n    var postalCode = singleLineAddress.match(/([0-9]{5})|([a-z][0-9][a-z] ?[0-9][a-z][0-9])/gi),\n        indexOfPostalCode = -1;\n\n    if (postalCode) {\n      postalCode = postalCode.pop(); // pick match closest to end\n\n      indexOfPostalCode = singleLineAddress.lastIndexOf(postalCode);\n\n      if (indexOfPostalCode == 0 && singleLineAddress.length > 10) {\n        // postal code is probably part of street address\n        postalCode = null;\n        indexOfPostalCode = -1;\n      }\n\n      if (postalCode) {\n        addressObj.postal_code = postalCode;\n        var everythingAfterPostalCode = singleLineAddress.substr(indexOfPostalCode + postalCode.length);\n        singleLineAddress = singleLineAddress.substr(0, indexOfPostalCode) + everythingAfterPostalCode;\n        var possibleCountry = everythingAfterPostalCode.replace(/\\s*,/, '').split(',').shift().trim();\n\n        if (possibleCountry && looksLikeCountry(possibleCountry)) {\n          addressObj.country = possibleCountry;\n          singleLineAddress = singleLineAddress.substr(0, indexOfPostalCode); // just ditch everything after postal + country\n        }\n      }\n    }\n\n    var addySplit = singleLineAddress.split(','); // Handle special cases...\n    // Neighborhood, City, State\n\n    if (addySplit.length == 3 && looksLikeState(addySplit[2])) {\n      addressObj.street_address1 = addySplit[0].trim();\n      addressObj.city = addySplit[1].trim();\n      addressObj.state = addySplit[2].trim();\n      return cb(false, addressObj);\n    } // Handle generic case...\n\n\n    addySplit.forEach(function (addyPart) {\n      if (!(addyPart = addyPart.trim())) return; // if has numbers, assume street address\n\n      if (/[0-9]/.test(addyPart)) {\n        return !addressObj.street_address1 && (addressObj.street_address1 = addyPart);\n      } // if looks like state\n\n\n      if (looksLikeState(addyPart) && !addressObj.state) {\n        return addressObj.state = addyPart;\n      } // if looks like country\n\n\n      if (looksLikeCountry(addyPart)) {\n        return !addressObj.country && (addressObj.country = addyPart);\n      } // else assume city\n\n\n      !addressObj.city && (addressObj.city = addyPart);\n    });\n    cb(false, addressObj);\n  });\n}\n\nfunction implodeAddress(addressObj, cb) {\n  process.nextTick(function () {\n    if (addressObj === null || typeof addressObj != 'object') {\n      //return cb(new Error('Input must be an Object'))\n      return cb(false, '');\n    }\n\n    var addyParts = [],\n        addyPart;\n\n    if (typeof addressObj.street_address1 == 'string' && (addyPart = addressObj.street_address1.trim())) {\n      addyParts[0] = addyPart;\n\n      if (typeof addressObj.street_address2 == 'string' && (addyPart = addressObj.street_address2.trim())) {\n        addyParts[0] += ' ' + addyPart;\n      }\n    }\n\n    ['city', 'state'].forEach(function (addyKey) {\n      if (typeof addressObj[addyKey] == 'string' && (addyPart = addressObj[addyKey].trim())) {\n        addyParts.push(addyPart);\n      }\n    });\n    var singleLineAddress = addyParts.join(', ');\n\n    if (typeof addressObj.postal_code == 'string' && (addyPart = addressObj.postal_code.trim())) {\n      singleLineAddress += ' ' + addyPart;\n      singleLineAddress = singleLineAddress.trim();\n    }\n\n    if (typeof addressObj.country == 'string' && (addyPart = addressObj.country.trim())) {\n      singleLineAddress += singleLineAddress ? ', ' + addyPart : addyPart;\n    }\n\n    cb(false, singleLineAddress);\n  });\n}\n\nvar states;\n\nfunction looksLikeState(str) {\n  if (!states) {\n    var map = require('./lib/states.json');\n\n    states = {};\n\n    for (var k in map) {\n      if (map.hasOwnProperty(k)) {\n        states[k.toLowerCase()] = true;\n        states[map[k].toLowerCase()] = true;\n      }\n    }\n  }\n\n  str = str.trim().toLowerCase();\n  return !!states[str];\n}\n\nvar countries;\n\nfunction looksLikeCountry(str) {\n  if (!countries) {\n    var map = require('./lib/countries.json');\n\n    countries = {};\n\n    for (var k in map) {\n      if (map.hasOwnProperty(k)) {\n        countries[k.toLowerCase()] = true;\n        countries[map[k].toLowerCase()] = true;\n      }\n    }\n  }\n\n  str = str.trim().toLowerCase();\n\n  if (str == 'usa') {\n    return true;\n  }\n\n  return !!countries[str];\n}","map":{"version":3,"sources":["C:/Users/nmtuc/Desktop/Dev/web/localsonly/frontend/node_modules/parse-address-string/index.js"],"names":["module","exports","explodeAddress","implodeAddress","singleLineAddress","cb","process","nextTick","addressObj","street_address1","city","state","postal_code","country","trim","postalCode","match","indexOfPostalCode","pop","lastIndexOf","length","everythingAfterPostalCode","substr","possibleCountry","replace","split","shift","looksLikeCountry","addySplit","looksLikeState","forEach","addyPart","test","addyParts","street_address2","addyKey","push","join","states","str","map","require","k","hasOwnProperty","toLowerCase","countries"],"mappings":"AACAA,MAAM,CAACC,OAAP,GAAiBC,cAAjB;AACAF,MAAM,CAACC,OAAP,CAAeC,cAAf,GAAgCA,cAAhC;AACAF,MAAM,CAACC,OAAP,CAAeE,cAAf,GAAgCA,cAAhC;;AAGA,SAASD,cAAT,CAAwBE,iBAAxB,EAA0CC,EAA1C,EAA6C;AAC5CC,EAAAA,OAAO,CAACC,QAAR,CAAiB,YAAU;AAC1B,QAAIC,UAAU,GAAG;AAChBC,MAAAA,eAAe,EAAE,IADD;AAEfC,MAAAA,IAAI,EAAE,IAFS;AAGfC,MAAAA,KAAK,EAAE,IAHQ;AAIfC,MAAAA,WAAW,EAAE,IAJE;AAKfC,MAAAA,OAAO,EAAE;AALM,KAAjB;;AAOA,QAAI,OAAOT,iBAAP,IAA4B,QAAhC,EAA0C;AACzC;AACA,aAAOC,EAAE,CAAC,KAAD,EAAOG,UAAP,CAAT;AACA;;AACDJ,IAAAA,iBAAiB,GAAGA,iBAAiB,CAACU,IAAlB,EAApB;AAEA,QAAIC,UAAU,GAAGX,iBAAiB,CAACY,KAAlB,CAAwB,iDAAxB,CAAjB;AAAA,QACEC,iBAAiB,GAAG,CAAC,CADvB;;AAEA,QAAIF,UAAJ,EAAgB;AACfA,MAAAA,UAAU,GAAGA,UAAU,CAACG,GAAX,EAAb,CADe,CACe;;AAC9BD,MAAAA,iBAAiB,GAAGb,iBAAiB,CAACe,WAAlB,CAA8BJ,UAA9B,CAApB;;AACA,UAAIE,iBAAiB,IAAI,CAArB,IAA0Bb,iBAAiB,CAACgB,MAAlB,GAA2B,EAAzD,EAA6D;AAC5D;AACAL,QAAAA,UAAU,GAAG,IAAb;AACAE,QAAAA,iBAAiB,GAAG,CAAC,CAArB;AACA;;AACD,UAAIF,UAAJ,EAAgB;AACfP,QAAAA,UAAU,CAACI,WAAX,GAAyBG,UAAzB;AACA,YAAIM,yBAAyB,GAAGjB,iBAAiB,CAACkB,MAAlB,CAAyBL,iBAAiB,GAACF,UAAU,CAACK,MAAtD,CAAhC;AACAhB,QAAAA,iBAAiB,GAAGA,iBAAiB,CAACkB,MAAlB,CAAyB,CAAzB,EAA2BL,iBAA3B,IAA8CI,yBAAlE;AACA,YAAIE,eAAe,GAAGF,yBAAyB,CAACG,OAA1B,CAAkC,MAAlC,EAAyC,EAAzC,EAA6CC,KAA7C,CAAmD,GAAnD,EAAwDC,KAAxD,GAAgEZ,IAAhE,EAAtB;;AACA,YAAIS,eAAe,IAAII,gBAAgB,CAACJ,eAAD,CAAvC,EAA0D;AACzDf,UAAAA,UAAU,CAACK,OAAX,GAAqBU,eAArB;AACAnB,UAAAA,iBAAiB,GAAGA,iBAAiB,CAACkB,MAAlB,CAAyB,CAAzB,EAA2BL,iBAA3B,CAApB,CAFyD,CAES;AAClE;AACD;AACD;;AAED,QAAIW,SAAS,GAAGxB,iBAAiB,CAACqB,KAAlB,CAAwB,GAAxB,CAAhB,CApC0B,CAsC1B;AACA;;AACA,QAAIG,SAAS,CAACR,MAAV,IAAoB,CAApB,IAAyBS,cAAc,CAACD,SAAS,CAAC,CAAD,CAAV,CAA3C,EAA2D;AAC1DpB,MAAAA,UAAU,CAACC,eAAX,GAA6BmB,SAAS,CAAC,CAAD,CAAT,CAAad,IAAb,EAA7B;AACAN,MAAAA,UAAU,CAACE,IAAX,GAAkBkB,SAAS,CAAC,CAAD,CAAT,CAAad,IAAb,EAAlB;AACAN,MAAAA,UAAU,CAACG,KAAX,GAAmBiB,SAAS,CAAC,CAAD,CAAT,CAAad,IAAb,EAAnB;AACA,aAAOT,EAAE,CAAC,KAAD,EAAOG,UAAP,CAAT;AACA,KA7CyB,CA+C1B;;;AACAoB,IAAAA,SAAS,CAACE,OAAV,CAAkB,UAASC,QAAT,EAAkB;AACnC,UAAI,EAAEA,QAAQ,GAAGA,QAAQ,CAACjB,IAAT,EAAb,CAAJ,EAAmC,OADA,CAEnC;;AACA,UAAI,QAAQkB,IAAR,CAAaD,QAAb,CAAJ,EAA4B;AAC3B,eAAO,CAACvB,UAAU,CAACC,eAAZ,KAAgCD,UAAU,CAACC,eAAX,GAA6BsB,QAA7D,CAAP;AACA,OALkC,CAMnC;;;AACA,UAAIF,cAAc,CAACE,QAAD,CAAd,IAA4B,CAACvB,UAAU,CAACG,KAA5C,EAAmD;AAClD,eAAOH,UAAU,CAACG,KAAX,GAAmBoB,QAA1B;AACA,OATkC,CAUnC;;;AACA,UAAIJ,gBAAgB,CAACI,QAAD,CAApB,EAAgC;AAC/B,eAAO,CAACvB,UAAU,CAACK,OAAZ,KAAwBL,UAAU,CAACK,OAAX,GAAqBkB,QAA7C,CAAP;AACA,OAbkC,CAcnC;;;AACA,OAACvB,UAAU,CAACE,IAAZ,KAAqBF,UAAU,CAACE,IAAX,GAAkBqB,QAAvC;AACA,KAhBD;AAkBA1B,IAAAA,EAAE,CAAC,KAAD,EAAOG,UAAP,CAAF;AACA,GAnED;AAoEA;;AAED,SAASL,cAAT,CAAwBK,UAAxB,EAAmCH,EAAnC,EAAsC;AACrCC,EAAAA,OAAO,CAACC,QAAR,CAAiB,YAAU;AAC1B,QAAIC,UAAU,KAAK,IAAf,IAAuB,OAAOA,UAAP,IAAqB,QAAhD,EAA0D;AACzD;AACA,aAAOH,EAAE,CAAC,KAAD,EAAQ,EAAR,CAAT;AACA;;AACD,QAAI4B,SAAS,GAAG,EAAhB;AAAA,QACEF,QADF;;AAEA,QAAI,OAAOvB,UAAU,CAACC,eAAlB,IAAqC,QAArC,KAAkDsB,QAAQ,GAAGvB,UAAU,CAACC,eAAX,CAA2BK,IAA3B,EAA7D,CAAJ,EAAqG;AACpGmB,MAAAA,SAAS,CAAC,CAAD,CAAT,GAAeF,QAAf;;AACA,UAAI,OAAOvB,UAAU,CAAC0B,eAAlB,IAAqC,QAArC,KAAkDH,QAAQ,GAAGvB,UAAU,CAAC0B,eAAX,CAA2BpB,IAA3B,EAA7D,CAAJ,EAAqG;AACpGmB,QAAAA,SAAS,CAAC,CAAD,CAAT,IAAgB,MAAIF,QAApB;AACA;AACD;;AACD,KAAC,MAAD,EAAQ,OAAR,EAAiBD,OAAjB,CAAyB,UAASK,OAAT,EAAiB;AACzC,UAAI,OAAO3B,UAAU,CAAC2B,OAAD,CAAjB,IAA8B,QAA9B,KAA2CJ,QAAQ,GAAGvB,UAAU,CAAC2B,OAAD,CAAV,CAAoBrB,IAApB,EAAtD,CAAJ,EAAuF;AACtFmB,QAAAA,SAAS,CAACG,IAAV,CAAeL,QAAf;AACA;AACD,KAJD;AAKA,QAAI3B,iBAAiB,GAAG6B,SAAS,CAACI,IAAV,CAAe,IAAf,CAAxB;;AACA,QAAI,OAAO7B,UAAU,CAACI,WAAlB,IAAiC,QAAjC,KAA8CmB,QAAQ,GAAGvB,UAAU,CAACI,WAAX,CAAuBE,IAAvB,EAAzD,CAAJ,EAA6F;AAC5FV,MAAAA,iBAAiB,IAAI,MAAI2B,QAAzB;AACA3B,MAAAA,iBAAiB,GAAGA,iBAAiB,CAACU,IAAlB,EAApB;AACA;;AACD,QAAI,OAAON,UAAU,CAACK,OAAlB,IAA6B,QAA7B,KAA0CkB,QAAQ,GAAGvB,UAAU,CAACK,OAAX,CAAmBC,IAAnB,EAArD,CAAJ,EAAqF;AACpFV,MAAAA,iBAAiB,IAAIA,iBAAiB,GAAG,OAAK2B,QAAR,GAAmBA,QAAzD;AACA;;AACD1B,IAAAA,EAAE,CAAC,KAAD,EAAOD,iBAAP,CAAF;AACA,GA3BD;AA4BA;;AAED,IAAIkC,MAAJ;;AACA,SAAST,cAAT,CAAwBU,GAAxB,EAA4B;AAC3B,MAAI,CAACD,MAAL,EAAa;AACZ,QAAIE,GAAG,GAAGC,OAAO,CAAC,mBAAD,CAAjB;;AACAH,IAAAA,MAAM,GAAG,EAAT;;AACA,SAAK,IAAII,CAAT,IAAcF,GAAd,EAAmB;AAClB,UAAIA,GAAG,CAACG,cAAJ,CAAmBD,CAAnB,CAAJ,EAA0B;AACzBJ,QAAAA,MAAM,CAACI,CAAC,CAACE,WAAF,EAAD,CAAN,GAA0B,IAA1B;AACAN,QAAAA,MAAM,CAACE,GAAG,CAACE,CAAD,CAAH,CAAOE,WAAP,EAAD,CAAN,GAA+B,IAA/B;AACA;AACD;AACD;;AACDL,EAAAA,GAAG,GAAGA,GAAG,CAACzB,IAAJ,GAAW8B,WAAX,EAAN;AACA,SAAO,CAAC,CAACN,MAAM,CAACC,GAAD,CAAf;AACA;;AAED,IAAIM,SAAJ;;AACA,SAASlB,gBAAT,CAA0BY,GAA1B,EAA8B;AAC7B,MAAI,CAACM,SAAL,EAAgB;AACf,QAAIL,GAAG,GAAGC,OAAO,CAAC,sBAAD,CAAjB;;AACAI,IAAAA,SAAS,GAAG,EAAZ;;AACA,SAAK,IAAIH,CAAT,IAAcF,GAAd,EAAmB;AAClB,UAAIA,GAAG,CAACG,cAAJ,CAAmBD,CAAnB,CAAJ,EAA0B;AACzBG,QAAAA,SAAS,CAACH,CAAC,CAACE,WAAF,EAAD,CAAT,GAA6B,IAA7B;AACAC,QAAAA,SAAS,CAACL,GAAG,CAACE,CAAD,CAAH,CAAOE,WAAP,EAAD,CAAT,GAAkC,IAAlC;AACA;AACD;AACD;;AACDL,EAAAA,GAAG,GAAGA,GAAG,CAACzB,IAAJ,GAAW8B,WAAX,EAAN;;AACA,MAAIL,GAAG,IAAI,KAAX,EAAkB;AACjB,WAAO,IAAP;AACA;;AACD,SAAO,CAAC,CAACM,SAAS,CAACN,GAAD,CAAlB;AACA","sourcesContent":["\nmodule.exports = explodeAddress\nmodule.exports.explodeAddress = explodeAddress\nmodule.exports.implodeAddress = implodeAddress\n\n\nfunction explodeAddress(singleLineAddress,cb){\n\tprocess.nextTick(function(){\n\t\tvar addressObj = {\n\t\t\tstreet_address1: null\n\t\t\t,city: null\n\t\t\t,state: null\n\t\t\t,postal_code: null\n\t\t\t,country: null\n\t\t}\n\t\tif (typeof singleLineAddress != 'string') {\n\t\t\t//return cb(new Error('Input must be a String'))\n\t\t\treturn cb(false,addressObj)\n\t\t}\n\t\tsingleLineAddress = singleLineAddress.trim()\n\n\t\tvar postalCode = singleLineAddress.match(/([0-9]{5})|([a-z][0-9][a-z] ?[0-9][a-z][0-9])/gi)\n\t\t\t,indexOfPostalCode = -1\n\t\tif (postalCode) {\n\t\t\tpostalCode = postalCode.pop() // pick match closest to end\n\t\t\tindexOfPostalCode = singleLineAddress.lastIndexOf(postalCode)\n\t\t\tif (indexOfPostalCode == 0 && singleLineAddress.length > 10) {\n\t\t\t\t// postal code is probably part of street address\n\t\t\t\tpostalCode = null\n\t\t\t\tindexOfPostalCode = -1\n\t\t\t}\n\t\t\tif (postalCode) {\n\t\t\t\taddressObj.postal_code = postalCode\n\t\t\t\tvar everythingAfterPostalCode = singleLineAddress.substr(indexOfPostalCode+postalCode.length)\n\t\t\t\tsingleLineAddress = singleLineAddress.substr(0,indexOfPostalCode)+everythingAfterPostalCode\n\t\t\t\tvar possibleCountry = everythingAfterPostalCode.replace(/\\s*,/,'').split(',').shift().trim()\n\t\t\t\tif (possibleCountry && looksLikeCountry(possibleCountry)) {\n\t\t\t\t\taddressObj.country = possibleCountry\n\t\t\t\t\tsingleLineAddress = singleLineAddress.substr(0,indexOfPostalCode) // just ditch everything after postal + country\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar addySplit = singleLineAddress.split(',')\n\n\t\t// Handle special cases...\n\t\t// Neighborhood, City, State\n\t\tif (addySplit.length == 3 && looksLikeState(addySplit[2])) {\n\t\t\taddressObj.street_address1 = addySplit[0].trim()\n\t\t\taddressObj.city = addySplit[1].trim()\n\t\t\taddressObj.state = addySplit[2].trim()\n\t\t\treturn cb(false,addressObj)\n\t\t}\n\n\t\t// Handle generic case...\n\t\taddySplit.forEach(function(addyPart){\n\t\t\tif (!(addyPart = addyPart.trim())) return\n\t\t\t// if has numbers, assume street address\n\t\t\tif (/[0-9]/.test(addyPart)) {\n\t\t\t\treturn !addressObj.street_address1 && (addressObj.street_address1 = addyPart)\n\t\t\t}\n\t\t\t// if looks like state\n\t\t\tif (looksLikeState(addyPart) && !addressObj.state) {\n\t\t\t\treturn addressObj.state = addyPart\n\t\t\t}\n\t\t\t// if looks like country\n\t\t\tif (looksLikeCountry(addyPart)) {\n\t\t\t\treturn !addressObj.country && (addressObj.country = addyPart)\n\t\t\t}\n\t\t\t// else assume city\n\t\t\t!addressObj.city && (addressObj.city = addyPart)\n\t\t})\n\n\t\tcb(false,addressObj)\n\t})\n}\n\nfunction implodeAddress(addressObj,cb){\n\tprocess.nextTick(function(){\n\t\tif (addressObj === null || typeof addressObj != 'object') {\n\t\t\t//return cb(new Error('Input must be an Object'))\n\t\t\treturn cb(false, '')\n\t\t}\n\t\tvar addyParts = []\n\t\t\t,addyPart\n\t\tif (typeof addressObj.street_address1 == 'string' && (addyPart = addressObj.street_address1.trim())) {\n\t\t\taddyParts[0] = addyPart\n\t\t\tif (typeof addressObj.street_address2 == 'string' && (addyPart = addressObj.street_address2.trim())) {\n\t\t\t\taddyParts[0] += ' '+addyPart\n\t\t\t}\n\t\t}\n\t\t['city','state'].forEach(function(addyKey){\n\t\t\tif (typeof addressObj[addyKey] == 'string' && (addyPart = addressObj[addyKey].trim())) {\n\t\t\t\taddyParts.push(addyPart)\n\t\t\t}\n\t\t})\n\t\tvar singleLineAddress = addyParts.join(', ')\n\t\tif (typeof addressObj.postal_code == 'string' && (addyPart = addressObj.postal_code.trim())) {\n\t\t\tsingleLineAddress += ' '+addyPart\n\t\t\tsingleLineAddress = singleLineAddress.trim()\n\t\t}\n\t\tif (typeof addressObj.country == 'string' && (addyPart = addressObj.country.trim())) {\n\t\t\tsingleLineAddress += singleLineAddress ? ', '+addyPart : addyPart\n\t\t}\n\t\tcb(false,singleLineAddress)\n\t})\n}\n\nvar states\nfunction looksLikeState(str){\n\tif (!states) {\n\t\tvar map = require('./lib/states.json')\n\t\tstates = {}\n\t\tfor (var k in map) {\n\t\t\tif (map.hasOwnProperty(k)){\n\t\t\t\tstates[k.toLowerCase()] = true\n\t\t\t\tstates[map[k].toLowerCase()] = true\n\t\t\t}\n\t\t}\n\t}\n\tstr = str.trim().toLowerCase()\n\treturn !!states[str]\n}\n\nvar countries\nfunction looksLikeCountry(str){\n\tif (!countries) {\n\t\tvar map = require('./lib/countries.json')\n\t\tcountries = {}\n\t\tfor (var k in map) {\n\t\t\tif (map.hasOwnProperty(k)){\n\t\t\t\tcountries[k.toLowerCase()] = true\n\t\t\t\tcountries[map[k].toLowerCase()] = true\n\t\t\t}\n\t\t}\n\t}\n\tstr = str.trim().toLowerCase()\n\tif (str == 'usa') {\n\t\treturn true\n\t}\n\treturn !!countries[str]\n}\n\n"]},"metadata":{},"sourceType":"script"}