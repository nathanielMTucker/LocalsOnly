{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar AbstractGeocoder = require('./abstractgeocoder');\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options     Options (language, clientId, apiKey)\n */\n\n\nvar YandexGeocoder = function YandexGeocoder(httpAdapter, options) {\n  this.options = ['apiKey'];\n  YandexGeocoder.super_.call(this, httpAdapter, options);\n};\n\nutil.inherits(YandexGeocoder, AbstractGeocoder);\n\nfunction _findKey(result, wantedKey) {\n  var val = null;\n  Object.keys(result).every(function (key) {\n    if (key === wantedKey) {\n      val = result[key];\n      return false;\n    }\n\n    if (typeof result[key] === 'object') {\n      val = _findKey(result[key], wantedKey);\n      return val === null ? true : false;\n    }\n\n    return true;\n  });\n  return val;\n}\n\nfunction _formatResult(result) {\n  var position = result.GeoObject.Point.pos.split(' ');\n  result = result.GeoObject.metaDataProperty.GeocoderMetaData.AddressDetails;\n  return {\n    'latitude': parseFloat(position[1]),\n    'longitude': parseFloat(position[0]),\n    'city': _findKey(result, 'LocalityName'),\n    'state': _findKey(result, 'AdministrativeAreaName'),\n    'streetName': _findKey(result, 'ThoroughfareName'),\n    'streetNumber': _findKey(result, 'PremiseNumber'),\n    'countryCode': _findKey(result, 'CountryNameCode'),\n    'country': _findKey(result, 'CountryName'),\n    'formattedAddress': _findKey(result, 'AddressLine')\n  };\n}\n\nfunction _processOptionsToParams(params, options) {\n  //language (language_region, ex: `ru_RU`, `uk_UA`)\n  if (options.language) {\n    params.lang = options.language;\n  } //results count (default 10)\n\n\n  if (options.results) {\n    params.results = options.results;\n  } //skip count (default 0)\n\n\n  if (options.skip) {\n    params.skip = options.skip;\n  } //Type of toponym (only for reverse geocoding)\n  //could be `house`, `street`, `metro`, `district`, `locality`\n\n\n  if (options.kind) {\n    params.kind = options.kind;\n  } //BBox (ex: `[[lat: 1.0, lng:2.0],[lat: 1.1, lng:2.2]]`)\n\n\n  if (options.bbox) {\n    if (options.bbox.length === 2) {\n      params.bbox = options.bbox[0].lng + ',' + options.bbox[0].lat;\n      params.bbox = params.bbox + '~';\n      params.bbox = params.bbox + options.bbox[1].lng + ',' + options.bbox[1].lat;\n    }\n  } //Limit search in bbox (1) or not limit (0)\n\n\n  if (options.rspn) {\n    params.rspn = options.rspn;\n  }\n\n  if (options.apiKey) {\n    params.apikey = options.apiKey;\n  }\n} // Yandex geocoding API endpoint\n\n\nYandexGeocoder.prototype._endpoint = 'https://geocode-maps.yandex.ru/1.x/';\n/**\n* Geocode\n* @param <string>   value    Value to geocode (Address)\n* @param <function> callback Callback method\n*/\n\nYandexGeocoder.prototype._geocode = function (value, callback) {\n  var params = {\n    geocode: value,\n    format: 'json'\n  };\n\n  _processOptionsToParams(params, this.options);\n\n  this.httpAdapter.get(this._endpoint, params, function (err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      var results = [];\n      result.response.GeoObjectCollection.featureMember.forEach(function (geopoint) {\n        results.push(_formatResult(geopoint));\n      });\n      results.raw = result;\n      callback(false, results);\n    }\n  });\n};\n/**\n * Reverse geocoding\n * @param {lat:<number>,lon:<number>}  lat: Latitude, lon: Longitude\n * @param <function> callback Callback method\n */\n\n\nYandexGeocoder.prototype._reverse = function (query, callback) {\n  var lat = query.lat;\n  var lng = query.lon;\n  var value = lng + ',' + lat;\n\n  this._geocode(value, callback);\n};\n\nmodule.exports = YandexGeocoder;","map":{"version":3,"sources":["C:/Users/nmtuc/Desktop/Dev/web/localsonly/frontend/node_modules/node-geocoder/lib/geocoder/yandexgeocoder.js"],"names":["util","require","AbstractGeocoder","YandexGeocoder","httpAdapter","options","super_","call","inherits","_findKey","result","wantedKey","val","Object","keys","every","key","_formatResult","position","GeoObject","Point","pos","split","metaDataProperty","GeocoderMetaData","AddressDetails","parseFloat","_processOptionsToParams","params","language","lang","results","skip","kind","bbox","length","lng","lat","rspn","apiKey","apikey","prototype","_endpoint","_geocode","value","callback","geocode","format","get","err","response","GeoObjectCollection","featureMember","forEach","geopoint","push","raw","_reverse","query","lon","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar util = require('util');\nvar AbstractGeocoder = require('./abstractgeocoder');\n\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options     Options (language, clientId, apiKey)\n */\nvar YandexGeocoder = function YandexGeocoder(httpAdapter, options) {\n  this.options = ['apiKey'];\n  YandexGeocoder.super_.call(this, httpAdapter, options);\n};\n\nutil.inherits(YandexGeocoder, AbstractGeocoder);\n\nfunction _findKey(result, wantedKey) {\n  var val = null;\n  Object.keys(result).every(function(key) {\n\n  if (key === wantedKey) {\n    val = result[key];\n    return false;\n  }\n\n  if (typeof result[key] === 'object') {\n    val = _findKey(result[key], wantedKey);\n\n    return val === null ? true : false;\n  }\n\n  return true;\n  });\n\n  return val;\n}\n\nfunction _formatResult(result) {\n  var position = result.GeoObject.Point.pos.split(' ');\n  result = result.GeoObject.metaDataProperty.GeocoderMetaData.AddressDetails;\n\n  return {\n    'latitude' : parseFloat(position[1]),\n    'longitude' : parseFloat(position[0]),\n    'city' : _findKey(result, 'LocalityName'),\n    'state' : _findKey(result, 'AdministrativeAreaName'),\n    'streetName': _findKey(result, 'ThoroughfareName'),\n    'streetNumber' : _findKey(result, 'PremiseNumber'),\n    'countryCode' : _findKey(result, 'CountryNameCode'),\n    'country' : _findKey(result, 'CountryName'),\n    'formattedAddress' : _findKey(result, 'AddressLine')\n  };\n}\n\nfunction _processOptionsToParams(params, options){\n\n  //language (language_region, ex: `ru_RU`, `uk_UA`)\n  if (options.language) {\n    params.lang = options.language;\n  }\n\n  //results count (default 10)\n  if (options.results) {\n    params.results = options.results;\n  }\n\n  //skip count (default 0)\n  if (options.skip) {\n    params.skip = options.skip;\n  }\n\n  //Type of toponym (only for reverse geocoding)\n  //could be `house`, `street`, `metro`, `district`, `locality`\n  if (options.kind) {\n    params.kind = options.kind;\n  }\n\n  //BBox (ex: `[[lat: 1.0, lng:2.0],[lat: 1.1, lng:2.2]]`)\n  if (options.bbox) {\n    if (options.bbox.length === 2){\n      params.bbox = options.bbox[0].lng + ',' + options.bbox[0].lat;\n      params.bbox = params.bbox + '~';\n      params.bbox = params.bbox + options.bbox[1].lng + ',' + options.bbox[1].lat;\n    }\n  }\n\n  //Limit search in bbox (1) or not limit (0)\n  if (options.rspn) {\n    params.rspn = options.rspn;\n  }\n\n  if(options.apiKey) {\n    params.apikey = options.apiKey;\n  }\n}\n\n// Yandex geocoding API endpoint\nYandexGeocoder.prototype._endpoint = 'https://geocode-maps.yandex.ru/1.x/';\n\n/**\n* Geocode\n* @param <string>   value    Value to geocode (Address)\n* @param <function> callback Callback method\n*/\nYandexGeocoder.prototype._geocode = function(value, callback) {\n  var params = {\n    geocode : value,\n    format: 'json'\n  };\n\n  _processOptionsToParams(params, this.options);\n\n  this.httpAdapter.get(this._endpoint, params, function(err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      var results = [];\n\n      result.response.GeoObjectCollection.featureMember.forEach(function(geopoint) {\n        results.push(_formatResult(geopoint));\n      });\n\n      results.raw = result;\n      callback(false, results);\n    }\n  });\n};\n\n/**\n * Reverse geocoding\n * @param {lat:<number>,lon:<number>}  lat: Latitude, lon: Longitude\n * @param <function> callback Callback method\n */\nYandexGeocoder.prototype._reverse = function (query, callback) {\n  var lat = query.lat;\n  var lng = query.lon;\n\n  var value = lng + ',' + lat;\n\n  this._geocode(value, callback);\n};\n\n\nmodule.exports = YandexGeocoder;\n"]},"metadata":{},"sourceType":"script"}